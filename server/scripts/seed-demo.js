/* eslint-disable no-console */
const crypto = require("crypto");

const API_URL = process.env.API_URL ?? "http://localhost:3000";
const EMAIL = process.env.SEED_EMAIL ?? "demo@timeflow.local";
const PASSWORD = process.env.SEED_PASSWORD ?? "Password123!";

function isoInHours(h) {
    const d = new Date(Date.now() + h * 60 * 60 * 1000);
    return d.toISOString();
}

// Extract task id from multiple possible response shapes
function pickTaskId(obj) {
    if (!obj || typeof obj !== "object") {
        return null;
    }

    if (typeof obj.id === "string") {
        return obj.id;
    }
    if (obj.task && typeof obj.task.id === "string") {
        return obj.task.id;
    }
    if (obj.data) {
        if (typeof obj.data.id === "string") {
            return obj.data.id;
        }
    }
}

async function req(path, opts = {}) {
    const res = await fetch(`${API_URL}${path}`, {
        ...opts,
        headers: {
            ...(opts.headers || {}),
            "Content-Type": "application/json",
        },
    });

    const text = await res.text();
    let body;
    try {
        body = JSON.parse(text);
    } catch {
        body = text;
    }

    if (!res.ok) {
        const msg = `HTTP ${res.status} ${path}: ${
            typeof body === "string" ? body : JSON.stringify(body)
        }`;
        const err = new Error(msg);
        err.status = res.status;
        err.body = body;
        throw err;
    }

    return body;
}

async function main() {
    console.log(`[seed] api=${API_URL}`);

    // 1) Register (ok if already exists), then login
    try {
        await req("/auth/register", {
            method: "POST",
            body: JSON.stringify({ email: EMAIL, password: PASSWORD }),
        });
        console.log(`[seed] registered ${EMAIL}`);
    } catch (e) {
        const msg = String(e?.message ?? e);

        // Allowed: user already exists (after you implement 409 on the backend)
        // Also allowed: if backend still returns 500 but with "EmailAlreadyExists" in body
        const allowed =
            msg.includes("HTTP 409") ||
            msg.includes("EmailAlreadyExists") ||
            (e?.body && typeof e.body === "object" && e.body.error === "EmailAlreadyExists");

        if (allowed) {
            console.log("[seed] user already exists, continuing");
        } else {
            throw e;
        }
    }

    const login = await req("/auth/login", {
        method: "POST",
        body: JSON.stringify({ email: EMAIL, password: PASSWORD }),
    });

    if (!login?.ok) {
        throw new Error(`Login failed: ${login?.error ?? "UnknownError"}`);
    }

    const token = login.accessToken;
    if (!token) {
        console.error("[seed] login response missing accessToken. Response was:");
        console.error(JSON.stringify(login, null, 2));
        throw new Error("Login succeeded but accessToken missing");
    }

    console.log("[seed] logged in");

    // 2) Create tasks (store ids only, robust to response shape)
    const tasksToCreate = Number(process.env.SEED_TASKS ?? 25);
    const createdIds = [];

    for (let i = 0; i < tasksToCreate; i++) {
        const dueAt = isoInHours(6 + (i % 10));
        const title = `Seed Task ${i + 1} - ${crypto.randomBytes(2).toString("hex")}`;

        const resp = await req("/tasks", {
            method: "POST",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({
            title,
            description: "generated by seed-demo",
            dueAt,
            }),
        });

        const id = pickTaskId(resp) || pickTaskId(resp?.task);
        if (!id) {
            console.error("[seed] create task response missing id. Response was:");
            console.error(JSON.stringify(resp, null, 2));
            throw new Error("POST /tasks did not return a task id");
        }

        createdIds.push(id);
    }

    console.log(`[seed] created tasks=${createdIds.length}`);

    // 3) Mark some as DONE, some as CANCELED
    const doneCount = Math.max(1, Math.floor(createdIds.length * 0.4));
    const cancelCount = Math.max(0, Math.floor(createdIds.length * 0.1));

    for (let i = 0; i < doneCount; i++) {
        const id = createdIds[i];
        await req(`/tasks/${id}`, {
            method: "PATCH",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({ status: "DONE" }),
        });
    }

    for (let i = doneCount; i < doneCount + cancelCount; i++) {
        const id = createdIds[i];
        await req(`/tasks/${id}`, {
            method: "PATCH",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({ status: "CANCELED" }),
        });
    }

    console.log(`[seed] done=${doneCount} canceled=${cancelCount}`);
    console.log("[seed] OK - now run python workers to compute features/segments");
}

main().catch((e) => {
    console.error("[seed] failed:", e?.message ?? e);
    process.exit(1);
});
