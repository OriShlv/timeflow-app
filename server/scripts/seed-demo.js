/* eslint-disable no-console */
const crypto = require("crypto");

const API_URL = process.env.API_URL ?? "http://localhost:3000";
const EMAIL = process.env.SEED_EMAIL ?? "demo@timeflow.local";
const PASSWORD = process.env.SEED_PASSWORD ?? "Password123!";

function isoInHours(h) {
    const d = new Date(Date.now() + h * 60 * 60 * 1000);
    return d.toISOString();
}

async function req(path, opts = {}) {
    const res = await fetch(`${API_URL}${path}`, {
        ...opts,
        headers: {
            ...(opts.headers || {}),
            "Content-Type": "application/json",
        },
    });

    const text = await res.text();
    let body;
    try { 
        body = JSON.parse(text); 
    } catch { 
        body = text; 
    }

    if (!res.ok) {
        throw new Error(`HTTP ${res.status} ${path}: ${typeof body === "string" ? body : JSON.stringify(body)}`);
    }

    return body;
}

async function main() {
    console.log(`[seed] api=${API_URL}`);
    // 1) Register (if exists - try login)
    let token = null;

    try {
        await req("/auth/register", {
            method: "POST",
            body: JSON.stringify({ email: EMAIL, password: PASSWORD }),
        });
        console.log(`[seed] registered ${EMAIL}`);
    } catch (e) {
        console.error(`[seed] register skipped (${e.message})`);
    }

    const login = await req("/auth/login", {
        method: "POST",
        body: JSON.stringify({ email: EMAIL, password: PASSWORD }),
    });
    if (!login.ok) {
        throw new Error(`Login failed: ${login.error}`);
    }
    token = login.accessToken;
    console.log(`[seed] logged in`);

    // 2) Create tasks
    const tasksToCreate = Number(process.env.SEED_TASKS ?? 25);
    const created = [];

    for (let i = 0; i < tasksToCreate; i++) {
        const dueAt = isoInHours(6 + (i % 10));
        const title = `Seed Task ${i + 1} - ${crypto.randomBytes(2).toString("hex")}`;
        const res = await req("/tasks", {
            method: "POST",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({
            title,
            description: "generated by seed-demo",
            dueAt,
            }),
        });
        created.push(res.task);
    }
    console.log(`[seed] created tasks=${created.length}`);

    // 3) Mark some as DONE, some as CANCELED
    const doneCount = Math.max(1, Math.floor(created.length * 0.4));
    const cancelCount = Math.max(0, Math.floor(created.length * 0.1));

    for (let i = 0; i < doneCount; i++) {
        const id = created[i].id;
        await req(`/tasks/${id}`, {
            method: "PATCH",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({ status: "DONE" }),
        });
    }

    for (let i = doneCount; i < doneCount + cancelCount; i++) {
        const id = created[i].id;
        await req(`/tasks/${id}`, {
            method: "PATCH",
            headers: { Authorization: `Bearer ${token}` },
            body: JSON.stringify({ status: "CANCELED" }),
        });
    }

    console.log(`[seed] done=${doneCount} canceled=${cancelCount}`);

    console.log(`[seed] OK - now run python workers to compute features/segments`);
}

main().catch((e) => {
    console.error("[seed] failed:", e);
    process.exit(1);
});
